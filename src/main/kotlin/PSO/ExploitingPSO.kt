package PSO

import gradientDescent.GradientDescent
import org.ejml.simple.SimpleMatrix
import utility.*
import kotlin.math.min

class BiBehavioralParticle<GD>(val velocityParticle: VelocityParticle, val gradientDescentParticle: GradientDescentParticle<GD>): Particle(velocityParticle.velocity.numCols(), velocityParticle.velocity.numRows(), -1.0 until 1.0) where GD: GradientDescent  {

    override var bestCost: Double = min(velocityParticle.bestCost, gradientDescentParticle.bestCost)
    override var bestPosition: SimpleMatrix = velocityParticle.bestPosition

}

class ExploitingPSO<GD>(modelInfo: ModelInfo, costCalculator: CostCalculator, particleCount: Int, val psoInfo: PSOInfo, gdFactory: () -> GD) : ParticleSwarmOptimization<BiBehavioralParticle<GD>>(modelInfo, costCalculator, 0) where GD: GradientDescent {
    override var swarms: MutableList<Swarm<BiBehavioralParticle<GD>>> = MutableList(1) { Swarm(
            MutableList(particleCount) {
                BiBehavioralParticle(
                        VelocityParticle(modelInfo.lumpingMatrix.numCols(), modelInfo.lumpingMatrix.numRows(), -1.0 until 1.0),
                        GradientDescentParticle(modelInfo.lumpingMatrix.numCols(), modelInfo.lumpingMatrix.numRows(), -1.0 until 1.0, gdFactory)
                ).apply { bestCost = costCalculator.cost(this.position) } }
    ) }

    override fun updateParticle(swarm: Swarm<BiBehavioralParticle<GD>>, particle: BiBehavioralParticle<GD>) {
        if (swarm.globalBestPosition == particle.bestPosition) {
            // Works as an exploiter
            particle.gradientDescentParticle.apply {
                gd.apply {
                    updateGradient()
                    iterate()
                }

                position = gd.lumpingMatrix
                particle.velocityParticle.position = gd.lumpingMatrix
            }
        } else {
            // Works as an explorer
            val velparticle = particle.velocityParticle

            val rand = { randMatrix(velparticle.velocity.numRows(), velparticle.velocity.numCols(), 0.0 until 1.0) }
            val randNumsParticle = rand()
            val randNumsGlobal = rand()

            var newVelocity = velparticle.velocity.scale(psoInfo.omegaMax - (psoInfo.omegaMax - psoInfo.omegaMin) / psoInfo.maxIterations * swarm.currentIteration) +
                    velparticle.bestPosition.minus(velparticle.position).hadamard(randNumsParticle).scale(psoInfo.accelParticle) +
                    swarm.globalBestPosition.minus(velparticle.position).hadamard(randNumsGlobal).scale(psoInfo.accelGlobal)

            // Ensure that locked rows have 0 velocity
            for (i in 0 until lockedRowCount)
                newVelocity = newVelocity.setRow(i, SimpleMatrix(newVelocity.numCols(), 1).create { _ -> 0.0 })

            velparticle.velocity = checkVelocityBound(newVelocity, psoInfo)
            velparticle.position = (velparticle.position + velparticle.velocity).MGSON()

            particle.position = velparticle.position
            particle.gradientDescentParticle.gd.lumpingMatrix = velparticle.position
        }
    }

    private fun checkVelocityBound(velocity: SimpleMatrix, psoInfo: PSOInfo): SimpleMatrix {
        val vMax = psoInfo.bounds.size / psoInfo.vMaxN

        val rVelocity = SimpleMatrix(velocity)

        for (i in 0 until rVelocity.numElements) {
            if (rVelocity[i] > vMax) rVelocity[i] = vMax
            if (rVelocity[i] < -vMax) rVelocity[i] = -vMax
        }

        return rVelocity
    }

}